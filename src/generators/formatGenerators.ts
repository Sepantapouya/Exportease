import { CollectionGroup, GeneratedFiles, Token, TokenAnalysis } from '../types';
import { StringUtils } from '../utils/stringUtils';

export abstract class BaseGenerator {
  protected static generateFileComment(collectionName: string, modeName: string): string {
    return `Generated by ExportEase Plugin\nCollection: ${collectionName}\nMode: ${modeName}`;
  }
}

export class CSSGenerator extends BaseGenerator {
  static generateCollectionCSS(collection: CollectionGroup): GeneratedFiles {
    const files: GeneratedFiles = {};
    
    collection.modes.forEach(mode => {
      const fileName = `${StringUtils.slugify(collection.name)}-${StringUtils.slugify(mode.name)}.css`;
      const content = this.generateCSS(mode.tokens, collection.name, mode.name);
      files[fileName] = content;
    });

    return files;
  }

  static generateComprehensiveCSS(group: TokenAnalysis): string {
    let css = `/* Generated by ExportEase Plugin */\n:root {\n`;
    
    group.collections.forEach(collection => {
      css += `\n  /* ${collection.name} */\n`;
      collection.modes.forEach(mode => {
        mode.tokens.forEach(token => {
          const cssVar = StringUtils.tokenToCSSVariable(token.name);
          css += `  --${cssVar}: ${token.value};\n`;
        });
      });
    });
    
    css += `}\n`;
    return css;
  }

  private static generateCSS(tokens: Token[], collectionName: string, modeName: string): string {
    let css = `/* ${this.generateFileComment(collectionName, modeName)} */\n\n`;
    css += `:root {\n`;
    
    tokens.forEach(token => {
      const cssVar = StringUtils.tokenToCSSVariable(token.name);
      css += `  --${cssVar}: ${token.value};\n`;
    });
    
    css += `}\n`;
    return css;
  }
}

export class SCSSGenerator extends BaseGenerator {
  static generateCollectionSCSS(collection: CollectionGroup): GeneratedFiles {
    const files: GeneratedFiles = {};
    
    collection.modes.forEach(mode => {
      const fileName = `${StringUtils.slugify(collection.name)}-${StringUtils.slugify(mode.name)}.scss`;
      const content = this.generateSCSS(mode.tokens, collection.name, mode.name);
      files[fileName] = content;
    });

    return files;
  }

  static generateComprehensiveSCSS(group: TokenAnalysis): string {
    let scss = `// Generated by ExportEase Plugin\n\n`;
    
    group.collections.forEach(collection => {
      scss += `// ${collection.name}\n`;
      collection.modes.forEach(mode => {
        mode.tokens.forEach(token => {
          const scssVar = StringUtils.tokenToSCSSVariable(token.name);
          scss += `$${scssVar}: ${token.value};\n`;
        });
      });
      scss += `\n`;
    });
    
    return scss;
  }

  private static generateSCSS(tokens: Token[], collectionName: string, modeName: string): string {
    let scss = `// ${this.generateFileComment(collectionName, modeName)}\n\n`;
    
    tokens.forEach(token => {
      const scssVar = StringUtils.tokenToSCSSVariable(token.name);
      scss += `$${scssVar}: ${token.value};\n`;
    });
    
    return scss;
  }
}

export class JSONGenerator extends BaseGenerator {
  static generateCollectionJSON(collection: CollectionGroup): GeneratedFiles {
    const files: GeneratedFiles = {};
    
    collection.modes.forEach(mode => {
      const fileName = `${StringUtils.slugify(collection.name)}-${StringUtils.slugify(mode.name)}.json`;
      const content = this.generateJSON(mode.tokens, collection.name, mode.name);
      files[fileName] = content;
    });

    return files;
  }

  static generateComprehensiveJSON(group: TokenAnalysis): string {
    const jsonObject: any = {
      _metadata: {
        generator: 'ExportEase Plugin',
        generated: new Date().toISOString()
      }
    };
    
    group.collections.forEach(collection => {
      const collectionKey = StringUtils.slugify(collection.name);
      jsonObject[collectionKey] = {};
      
      collection.modes.forEach(mode => {
        const modeKey = StringUtils.slugify(mode.name);
        jsonObject[collectionKey][modeKey] = {};
        
        mode.tokens.forEach(token => {
          const tokenKey = StringUtils.tokenToJSVariable(token.name);
          jsonObject[collectionKey][modeKey][tokenKey] = {
            value: token.value,
            type: token.type
          };
        });
      });
    });
    
    return JSON.stringify(jsonObject, null, 2);
  }

  private static generateJSON(tokens: Token[], collectionName: string, modeName: string): string {
          const jsonObject: any = {
        _metadata: {
          generator: 'ExportEase Plugin',
          collection: collectionName,
          mode: modeName,
          generated: new Date().toISOString()
        }
      };
    
    tokens.forEach(token => {
      const tokenKey = StringUtils.tokenToJSVariable(token.name);
      jsonObject[tokenKey] = {
        value: token.value,
        type: token.type
      };
    });
    
    return JSON.stringify(jsonObject, null, 2);
  }
}

export class JSGenerator extends BaseGenerator {
  static generateCollectionJS(collection: CollectionGroup): GeneratedFiles {
    const files: GeneratedFiles = {};
    
    collection.modes.forEach(mode => {
      const fileName = `${StringUtils.slugify(collection.name)}-${StringUtils.slugify(mode.name)}.js`;
      const content = this.generateJS(mode.tokens, collection.name, mode.name);
      files[fileName] = content;
    });

    return files;
  }

  static generateComprehensiveJS(group: TokenAnalysis): string {
    let js = `// Generated by ExportEase Plugin\n\n`;
    js += `export const tokens = {\n`;
    
    group.collections.forEach(collection => {
      const collectionKey = StringUtils.slugify(collection.name);
      js += `  ${collectionKey}: {\n`;
      
      collection.modes.forEach(mode => {
        const modeKey = StringUtils.slugify(mode.name);
        js += `    ${modeKey}: {\n`;
        
        mode.tokens.forEach(token => {
          const tokenKey = StringUtils.tokenToJSVariable(token.name);
          js += `      ${tokenKey}: '${token.value}',\n`;
        });
        
        js += `    },\n`;
      });
      
      js += `  },\n`;
    });
    
    js += `};\n\nexport default tokens;\n`;
    return js;
  }

  private static generateJS(tokens: Token[], collectionName: string, modeName: string): string {
    let js = `// ${this.generateFileComment(collectionName, modeName)}\n\n`;
    js += `export const ${StringUtils.slugify(collectionName)}${StringUtils.toPascalCase(modeName)} = {\n`;
    
    tokens.forEach(token => {
      const tokenKey = StringUtils.tokenToJSVariable(token.name);
      js += `  ${tokenKey}: '${token.value}',\n`;
    });
    
    js += `};\n\nexport default ${StringUtils.slugify(collectionName)}${StringUtils.toPascalCase(modeName)};\n`;
    return js;
  }
}

export class DartGenerator extends BaseGenerator {
  static generateCollectionDart(collection: CollectionGroup): GeneratedFiles {
    const files: GeneratedFiles = {};
    
    collection.modes.forEach(mode => {
      const fileName = `${StringUtils.slugify(collection.name)}_${StringUtils.slugify(mode.name)}.dart`;
      const content = this.generateDart(mode.tokens, collection.name, mode.name);
      files[fileName] = content;
    });

    return files;
  }

  static generateComprehensiveDart(group: TokenAnalysis): string {
    let dart = `// Generated by ExportEase Plugin\n\n`;
    dart += `class DesignTokens {\n`;
    dart += `  DesignTokens._();\n\n`;
    
    group.collections.forEach(collection => {
      dart += `  // ${collection.name}\n`;
      collection.modes.forEach(mode => {
        dart += `  // ${mode.name}\n`;
        mode.tokens.forEach(token => {
          const dartVar = StringUtils.tokenToDartVariable(token.name);
          const dartValue = this.formatDartValue(token.value, token.type);
          dart += `  static const ${dartVar} = ${dartValue};\n`;
        });
      });
      dart += `\n`;
    });
    
    dart += `}\n`;
    return dart;
  }

  private static generateDart(tokens: Token[], collectionName: string, modeName: string): string {
    let dart = `// ${this.generateFileComment(collectionName, modeName)}\n\n`;
    const className = `${StringUtils.toPascalCase(collectionName)}${StringUtils.toPascalCase(modeName)}`;
    dart += `class ${className} {\n`;
    dart += `  ${className}._();\n\n`;
    
    tokens.forEach(token => {
      const dartVar = StringUtils.tokenToDartVariable(token.name);
      const dartValue = this.formatDartValue(token.value, token.type);
      dart += `  static const ${dartVar} = ${dartValue};\n`;
    });
    
    dart += `}\n`;
    return dart;
  }

  private static formatDartValue(value: string, type: string): string {
    switch (type) {
      case 'COLOR':
        if (value.startsWith('rgb(')) {
          // Convert rgb(r, g, b) to Dart Color
          const match = value.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
          if (match) {
            const [, r, g, b] = match;
            return `Color.fromRGBO(${r}, ${g}, ${b}, 1.0)`;
          }
        }
        return `'${value}'`;
      case 'FLOAT':
        return value;
      default:
        return `'${value}'`;
    }
  }
}

export class TailwindGenerator extends BaseGenerator {
  static generateCollectionTailwind(collection: CollectionGroup): GeneratedFiles {
    const files: GeneratedFiles = {};
    
    collection.modes.forEach(mode => {
      const fileName = `${StringUtils.slugify(collection.name)}-${StringUtils.slugify(mode.name)}.js`;
      const content = this.generateTailwind(mode.tokens, collection.name, mode.name);
      files[fileName] = content;
    });

    return files;
  }

  static generateComprehensiveTailwind(group: TokenAnalysis): string {
    let tailwind = `// Generated by ExportEase Plugin\n// Tailwind CSS configuration\n\n`;
    tailwind += `module.exports = {\n`;
    tailwind += `  theme: {\n`;
    tailwind += `    extend: {\n`;
    
    // Group tokens by type for better Tailwind organization
    const colorTokens: Token[] = [];
    const spacingTokens: Token[] = [];
    const otherTokens: Token[] = [];
    
    group.collections.forEach(collection => {
      collection.modes.forEach(mode => {
        mode.tokens.forEach(token => {
          if (token.type === 'COLOR') {
            colorTokens.push(token);
          } else if (token.type === 'FLOAT' && (token.name.includes('spacing') || token.name.includes('gap') || token.name.includes('margin') || token.name.includes('padding'))) {
            spacingTokens.push(token);
          } else {
            otherTokens.push(token);
          }
        });
      });
    });
    
    if (colorTokens.length > 0) {
      tailwind += `      colors: {\n`;
      colorTokens.forEach(token => {
        const tailwindVar = StringUtils.tokenToTailwindVariable(token.name);
        tailwind += `        '${tailwindVar}': '${token.value}',\n`;
      });
      tailwind += `      },\n`;
    }
    
    if (spacingTokens.length > 0) {
      tailwind += `      spacing: {\n`;
      spacingTokens.forEach(token => {
        const tailwindVar = StringUtils.tokenToTailwindVariable(token.name);
        tailwind += `        '${tailwindVar}': '${token.value}',\n`;
      });
      tailwind += `      },\n`;
    }
    
    tailwind += `    },\n`;
    tailwind += `  },\n`;
    tailwind += `};\n`;
    
    return tailwind;
  }

  private static generateTailwind(tokens: Token[], collectionName: string, modeName: string): string {
    let tailwind = `// ${this.generateFileComment(collectionName, modeName)}\n// Tailwind CSS configuration\n\n`;
    tailwind += `module.exports = {\n`;
    tailwind += `  theme: {\n`;
    tailwind += `    extend: {\n`;
    tailwind += `      // ${collectionName} - ${modeName}\n`;
    
    // Group by type
    const byType: Record<string, Token[]> = {};
    tokens.forEach(token => {
      if (!byType[token.type]) byType[token.type] = [];
      byType[token.type].push(token);
    });
    
    Object.entries(byType).forEach(([type, typeTokens]) => {
      const section = type === 'COLOR' ? 'colors' : 'variables';
      tailwind += `      ${section}: {\n`;
      typeTokens.forEach(token => {
        const tailwindVar = StringUtils.tokenToTailwindVariable(token.name);
        tailwind += `        '${tailwindVar}': '${token.value}',\n`;
      });
      tailwind += `      },\n`;
    });
    
    tailwind += `    },\n`;
    tailwind += `  },\n`;
    tailwind += `};\n`;
    
    return tailwind;
  }
} 