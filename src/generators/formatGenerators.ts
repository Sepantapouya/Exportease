import { CollectionGroup, GeneratedFiles, Token, TokenAnalysis } from '../types';
import { StringUtils } from '../utils/stringUtils';

export abstract class BaseGenerator {
  protected static generateFileComment(collectionName: string, modeName: string): string {
    return `Generated by ExportEase Plugin\nCollection: ${collectionName}\nMode: ${modeName}\nGenerated: ${new Date().toISOString()}`;
  }
}

export class CSSGenerator extends BaseGenerator {
  static generateCollectionCSS(collection: CollectionGroup): GeneratedFiles {
    const files: GeneratedFiles = {};
    
    collection.modes.forEach(mode => {
      const fileName = `${StringUtils.slugify(collection.name)}-${StringUtils.slugify(mode.name)}.css`;
      const content = this.generateCSS(mode.tokens, collection.name, mode.name);
      files[fileName] = content;
    });

    return files;
  }

  static generateComprehensiveCSS(group: TokenAnalysis): string {
    let css = `/* Generated by ExportEase Plugin */\n\n:root {\n`;
    
    group.collections.forEach(collection => {
      css += `  /* ${collection.name} */\n`;
      collection.modes.forEach(mode => {
        css += `  /* ${mode.name} */\n`;
        mode.tokens.forEach(token => {
          const cssVar = StringUtils.tokenToCSSVariable(token.name);
          css += `  --${cssVar}: ${token.value};\n`;
        });
      });
      css += `\n`;
    });
    
    css += `}\n`;
    return css;
  }

  private static generateCSS(tokens: Token[], collectionName: string, modeName: string): string {
    let css = `/* ${this.generateFileComment(collectionName, modeName)} */\n\n:root {\n`;
    
    tokens.forEach(token => {
      const cssVar = StringUtils.tokenToCSSVariable(token.name);
      css += `  --${cssVar}: ${token.value};\n`;
    });
    
    css += `}\n`;
    return css;
  }
}

export class SCSSGenerator extends BaseGenerator {
  static generateCollectionSCSS(collection: CollectionGroup): GeneratedFiles {
    const files: GeneratedFiles = {};
    
    collection.modes.forEach(mode => {
      const fileName = `${StringUtils.slugify(collection.name)}-${StringUtils.slugify(mode.name)}.scss`;
      const content = this.generateSCSS(mode.tokens, collection.name, mode.name);
      files[fileName] = content;
    });

    return files;
  }

  static generateComprehensiveSCSS(group: TokenAnalysis): string {
    let scss = `// Generated by ExportEase Plugin\n\n`;
    
    group.collections.forEach(collection => {
      scss += `// ${collection.name}\n`;
      collection.modes.forEach(mode => {
        scss += `// ${mode.name}\n`;
        mode.tokens.forEach(token => {
          const scssVar = StringUtils.tokenToSCSSVariable(token.name);
          scss += `$${scssVar}: ${token.value};\n`;
        });
      });
      scss += `\n`;
    });
    
    return scss;
  }

  private static generateSCSS(tokens: Token[], collectionName: string, modeName: string): string {
    let scss = `// ${this.generateFileComment(collectionName, modeName)}\n\n`;
    
    tokens.forEach(token => {
      const scssVar = StringUtils.tokenToSCSSVariable(token.name);
      scss += `$${scssVar}: ${token.value};\n`;
    });
    
    return scss;
  }
}

export class JSGenerator extends BaseGenerator {
  static generateCollectionJS(collection: CollectionGroup): GeneratedFiles {
    const files: GeneratedFiles = {};
    
    collection.modes.forEach(mode => {
      const fileName = `${StringUtils.slugify(collection.name)}-${StringUtils.slugify(mode.name)}.js`;
      const content = this.generateJS(mode.tokens, collection.name, mode.name);
      files[fileName] = content;
    });

    return files;
  }

  static generateComprehensiveJS(group: TokenAnalysis): string {
    let js = `// Generated by ExportEase Plugin\n\n`;
    js += `export const tokens = {\n`;
    
    group.collections.forEach(collection => {
      const collectionKey = StringUtils.slugify(collection.name);
      js += `  ${collectionKey}: {\n`;
      
      collection.modes.forEach(mode => {
        const modeKey = StringUtils.slugify(mode.name);
        js += `    ${modeKey}: {\n`;
        
        mode.tokens.forEach(token => {
          const tokenKey = StringUtils.tokenToJSVariable(token.name);
          js += `      ${tokenKey}: '${token.value}',\n`;
        });
        
        js += `    },\n`;
      });
      
      js += `  },\n`;
    });
    
    js += `};\n\nexport default tokens;\n`;
    return js;
  }

  private static generateJS(tokens: Token[], collectionName: string, modeName: string): string {
    let js = `// ${this.generateFileComment(collectionName, modeName)}\n\n`;
    js += `export const ${StringUtils.slugify(collectionName)}${StringUtils.toPascalCase(modeName)} = {\n`;
    
    tokens.forEach(token => {
      const tokenKey = StringUtils.tokenToJSVariable(token.name);
      js += `  ${tokenKey}: '${token.value}',\n`;
    });
    
    js += `};\n\nexport default ${StringUtils.slugify(collectionName)}${StringUtils.toPascalCase(modeName)};\n`;
    return js;
  }
}

export class TailwindGenerator extends BaseGenerator {
  static generateCollectionTailwind(collection: CollectionGroup): GeneratedFiles {
    const files: GeneratedFiles = {};
    
    collection.modes.forEach(mode => {
      const fileName = `${StringUtils.slugify(collection.name)}-${StringUtils.slugify(mode.name)}.js`;
      const content = this.generateTailwind(mode.tokens, collection.name, mode.name);
      files[fileName] = content;
    });

    return files;
  }

  static generateComprehensiveTailwind(group: TokenAnalysis): string {
    let tailwind = `// Generated by ExportEase Plugin\n// Tailwind CSS configuration\n\n`;
    tailwind += `module.exports = {\n`;
    tailwind += `  theme: {\n`;
    tailwind += `    extend: {\n`;
    
    // Group tokens by type for better Tailwind organization
    const colorTokens: Token[] = [];
    const spacingTokens: Token[] = [];
    const otherTokens: Token[] = [];
    
    group.collections.forEach(collection => {
      collection.modes.forEach(mode => {
        mode.tokens.forEach(token => {
          if (token.type === 'COLOR') {
            colorTokens.push(token);
          } else if (token.type === 'FLOAT' && (token.name.includes('spacing') || token.name.includes('gap') || token.name.includes('margin') || token.name.includes('padding'))) {
            spacingTokens.push(token);
          } else {
            otherTokens.push(token);
          }
        });
      });
    });
    
    if (colorTokens.length > 0) {
      tailwind += `      colors: {\n`;
      colorTokens.forEach(token => {
        const tailwindVar = StringUtils.tokenToTailwindVariable(token.name);
        tailwind += `        '${tailwindVar}': '${token.value}',\n`;
      });
      tailwind += `      },\n`;
    }
    
    if (spacingTokens.length > 0) {
      tailwind += `      spacing: {\n`;
      spacingTokens.forEach(token => {
        const tailwindVar = StringUtils.tokenToTailwindVariable(token.name);
        tailwind += `        '${tailwindVar}': '${token.value}',\n`;
      });
      tailwind += `      },\n`;
    }
    
    tailwind += `    },\n`;
    tailwind += `  },\n`;
    tailwind += `};\n`;
    
    return tailwind;
  }

  private static generateTailwind(tokens: Token[], collectionName: string, modeName: string): string {
    let tailwind = `// ${this.generateFileComment(collectionName, modeName)}\n// Tailwind CSS configuration\n\n`;
    tailwind += `module.exports = {\n`;
    tailwind += `  theme: {\n`;
    tailwind += `    extend: {\n`;
    tailwind += `      // ${collectionName} - ${modeName}\n`;
    
    // Group by type
    const byType: Record<string, Token[]> = {};
    tokens.forEach(token => {
      if (!byType[token.type]) byType[token.type] = [];
      byType[token.type].push(token);
    });
    
    Object.entries(byType).forEach(([type, typeTokens]) => {
      const section = type === 'COLOR' ? 'colors' : 'variables';
      tailwind += `      ${section}: {\n`;
      typeTokens.forEach(token => {
        const tailwindVar = StringUtils.tokenToTailwindVariable(token.name);
        tailwind += `        '${tailwindVar}': '${token.value}',\n`;
      });
      tailwind += `      },\n`;
    });
    
    tailwind += `    },\n`;
    tailwind += `  },\n`;
    tailwind += `};\n`;
    
    return tailwind;
  }
} 